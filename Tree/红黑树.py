"""
红黑树：特殊的二叉搜索树，最大特点是：自平衡 适用于插入/删除频繁，而AVL树适用于查询多，增/删少的
AVL 插入删除需要经常左旋后旋会很耗时来满足左右子树高度差小于1，而红黑树不用保证左右子树高度差小于1
应用：
1.Java中的TreeMap，JDK1.8中的HashMap
2. Linux的的进程调度，用红黑树管理进程控制块，进程的虚拟内存空间都存储在一颗红黑树上，每个虚拟内存空间都对应红黑树的一个节点，左指针指向相邻的虚拟内存空间，右指针指向相邻的高地址虚拟内存空间;
3. IO多路复用的epoll采用红黑树组织管理sockfd，以支持快速的增删改查;
4. Nginx中用红黑树管理定时器，因为红黑树是有序的，可以很快的得到距离当前最小的定时器;
5.C++ STL中的map实现
6.Windows NT内核中广泛存在

https://blog.csdn.net/z649431508/article/details/78034751

红黑树
1 根结点必须是黑色，叶结点是不存储数据的黑色空结点
2 相邻两个结点不能同时为红色，就红黑相邻
3 任意节点到其可到达的叶节点间包含相同数量的黑色节点(重点)
原理
1 没有一条路径比其他路径长出2倍
2 树的高度趋近log n ,所以插入/删除/查询的时间复杂度都是log n
3 一颗n个结点的红黑树最多是2倍的log(n+1)，即2log(n+1)
4 删掉红色结点后得到的树，每个结点到叶结点的路径长度都是相同的，是一颗最多有四条分枝的完全四叉树，其高度不会超过log(n+1)
5 一颗具有n个结点的完全二叉树，高度最多是log n
6 只有黑色节点的路径最长不超过log(n+1)，即使这条路径上的每个黑色结点，都对应一个红色结点，路径长度也不会超过2倍的log(n+1)
对于AVL严格的平衡二叉树，其查找效率一定不超过log n，红黑树没有它查找效率高
但插入删除AVL需要更多时间来左旋右旋，对比红黑树插入删除点只需更改标记的颜色，其插入删除查询更加稳定，所以日常用的更多

named after inventors Adelson-Velsky and Landis 用于搜索不那么频繁，插入删除更频繁的
https://www.bilibili.com/video/BV1Tb4y197Fe?spm_id_from=333.337.search-card.all.click

BST 二叉搜索二叉树
AVL BST+自平衡  平衡二叉树  平均和最差时间复杂度：插入删除查询都是log n
RBT 左右子树差一倍以内 O(log n)
对比 AVL：左右子树高度差<1。   RBT: 两条路径上的黑结点相同
面试回答java 8底层为啥用红黑树而不用AVL？ 因为红黑树的自平衡条件更为宽松，结点插入删除，它所带来整颗树的变动小很多
可视化网站
https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
https://blog.csdn.net/weixin_40583722/article/details/100195575
"""
